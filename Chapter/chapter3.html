<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <title>Quantum Computing</title>
	<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

	<style>
        #centerImg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: auto;
        }

		#cnot {
			text-align: center;
		}

		.cnotContainer {
            display: flex;
        }

        .box {
			margin-right: 10px; /* Adjust the margin between divs as needed */
            display: inline-block; /
			background-color: #fff; /* Set background color as needed */
        }
    </style>

</head>


<body>

<!--    <header onclick="window.location.href = '../index.html';">-->
<!--    	<h1>Hongfeng Zhang</h1>-->
<!--	</header>-->

    <nav>
        <div class="container">
            <ul>
<!--                <li><a href="#Post">Post</a></li>-->
				<li><a href="../index.html">Home</a></li>
                <li><a href="../Research.html">Research</a></li>
                <li><a href="../Learn.html">Learn</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>
		<section id="about" class="about">
        <div class="container">
			<h1 id="chapter">Chapter 3 Quantum Circuit</h1>
			<h2>3. 1 Quantum Bit</h2>
			<p>In classical computing, the bit is the fundamental unit of information and the basic building block of digital data. A bit can represent one of two states, typically denoted as 0 or 1. Electronic devices, such as transistors in computer circuits, are well-suited to this binary system, as they can easily build between two states-typically represented by high and low voltage.
				This binary nature makes bits a natural choice for encoding information in digital systems. The manipulation of bits underpins all digital computation and information processing in classical computers</p>

			<p>In quantum computing, the quantum bit, also called qubit, is the fundamental unit of quantum information. Unlike classical bits which can only exist in a definite state of either 0 or 1,
				a qubit has the unique ability to exist in a superposition of both 0 and 1 simultaneously. This property can perform more complex computation than classical bits.
				However, When measurements happen on qubits, the superposition collapses, and the qubit assumes a definite state of either 0 or 1.
				The outcome is probabilistic, introducing an element of uncertainty. The probabilities assigned during the superposition influence the likelihood of the qubit collapsing into a particular state.</p>
			
			<p>In quantum information theory, a quantum state is denoted as |\(\psi\)>. The quantum state corresponding to 0 is represented as |0>,
				and the quantum state corresponding to 1 is denoted as |1>. Unlike a classical bit which is represented by either 0 or 1, a qubit can exist in both quantum state |0> and |1>, requiring a two-dimensional vector for its representation.</p>
			<p>	In this representation, the first number of the vector represents the amplitude for the state |0>, and the other represents the amplitude for the state |1>.
				The computational basis states, which are the most common way to represent a qubit, are given by:
			<p>\[
				|0> = \begin{pmatrix}
						1 \\
						0
						\end{pmatrix}
				, |1> = \begin{pmatrix}
							0\\
							1
						\end{pmatrix}\]
			</p>

			</p>However, a qubit can also be represented using other orthogonal vector, depending on the context.
				For example, another representation might involve: </p>

			<p>\[|0> = \begin{pmatrix}
							\frac{1}{\sqrt{2}} \\
							\frac{1}{\sqrt{2}}
						\end{pmatrix},

				|1> = \begin{pmatrix}
							\frac{1}{\sqrt{2}} \\
							-\frac{1}{\sqrt{2}}
					\end{pmatrix}\]
			</p>
			<p>This representation is more complex than the first one but is sometimes useful in specific situations.
			A qubit can be described as a line superposition of two elementary orthogonal states |0> and |1>, capturing all ranges of quantum states.

			For example, an arbitrary quantum states is given by: </p>

			<p id="eq1">\[|\psi> = \alpha|0> + \beta|1> = \alpha \begin{pmatrix}
            1 \\
            0
            \end{pmatrix} + \beta \begin{pmatrix}
            0 \\
            1
            \end{pmatrix} = \begin{pmatrix}
            \alpha \\
            \beta
            \end{pmatrix}\]</p>
			<p>The two coordinates, \(\alpha\) and \(\beta\), are known as qubit amplitudes. These amplitudes determine the probability of the qubit
				collapsing into a particular quantum state when measurement. Although the outcome of a measurement is not deterministic,
				but the total probability across all quantum states is certain to equal 1.</p>
			<p>	When a qubit is measured, the probability of it yielding the quantum state |0> is given by \(|\alpha|^{2}\),
				and the probability of yielding the quantum state |1> is given by \(|\beta|^{2}\). These probabilities reflect the likelihood
				of each outcome, with the sum of \(|\alpha|^{2}\) and \(|\beta|^{2}\) being equal to 1, ensuring that all possible outcomes are account for</p>
			<p>\[|\alpha|^{2} + |\beta|^{2} = 1\]</p>

			<p>In a multi-qubit system, the state of the entire system is described by the combined quantum states of each individual qubit.
				The state of an n-qubit system is represented as a linear combination of basis states to all possible outcomes of qubits.
				This system's quantum state can be described by a \(2^n\) dimensional vector, where n is the number of qubits.
				Each element of this vector corresponds to a possible basis state of the system, with the entire state being a superposition of these basis states.
				For example, an arbitrary quantum state with an n-qubit system is given by: </p>
			<p>\[
					|\psi> = \begin{pmatrix}
            				\alpha_{0} \\
							\alpha_{1} \\

							\vdots \\
            				\alpha_{2^n - 1} \\
							\end{pmatrix}
				\]</p>
			<p>Here, \(\alpha_{0}\) represents the amplitude of the quantum state \(|000....000>\)(the binary representation with n bit of the number 0),
				\(\alpha_{2^n-1}\) represents the amplitude of the quantum state \(|111....111>\)(the binary representation with n bit of the number \(2^n-1\))</p>



			<p>In the case of a 2-qubit system, the basis state |00>, |01>, |10>, and |11> can be denoted as a 4-dimensional vector:</p>
			<p>\[|00> = \begin{pmatrix}
            1 \\
            0 \\
            0 \\
            0 \\
            \end{pmatrix}, |01> = \begin{pmatrix}
            0 \\
            1 \\
            0 \\
            0 \\
            \end{pmatrix}, |10> = \begin{pmatrix}
            0 \\
            0 \\
            1 \\
            0 \\
            \end{pmatrix}, |11> = \begin{pmatrix}
            0 \\
            0 \\
            0 \\
            1 \\
            \end{pmatrix} \]</p> 

			<p>These vectors form the basis for the 2-qubit system, and a quantum state of this system can be described as a linear combination of these basis vectors.
				For example, a qubit in a 2-qubit system can be expressed in a superposition of four basis states:</p>
			<p>\[|\psi> = \alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11> = \begin{pmatrix}
            \alpha_{00} \\
            \alpha_{01} \\
            \alpha_{10} \\
            \alpha_{11} \\
            \end{pmatrix}\]</p>
			<p>Here, \(\alpha_{00}, \alpha_{01}, \alpha_{10}\), and \(\alpha_{11}\) are quantum amplitudes of |00>, |01>, |10>, and |11>,</p>

			<p>\[|\alpha_{00}|^{2} + |\alpha_{01}|^{2} + |\alpha_{10}|^{2} + |\alpha_{11}|^{2} = 1\]</p>
	</div>
        </section>

		<section id="about" class="about">
		<div class="container">
			<h2>3.2 Quantum Logic Gates</h2>
			<p>Quantum logic Gates, also called quantum gates, are fundamental components in the field of quantum computing. Similar to classical logic gates which are the building blocks of classical circuits, quantum gates are used to construct quantum circuits.
				These gates manipulate quantum bits, from one quantum state \(|\psi>\) to another state \(|\psi'>\).</p>
			<p>For example, consider a quantum gate denoted as U. The relationship between the input quantum state \(|\psi>\) and output state \(|\psi'>\) can be expressed: </p>
			<p>\[|\psi'> = U|\psi>\]</p>
			<p>Here, the quantum state \(|\psi>\) and \(|\psi'>\) are unitary vectors, so the operator U is unitary.
				This unitary is the most important property of quantum gates, as it ensures the preservation of probability and the reversibility of quantum operations. </p>
			<p>Quantum gates are represented by unitary matrices. The common types of quantum gates include:</p>

			<ul>
				<li><b>One-qubit gates</b>: Pauli gates (X gate, Y gate and Z gate), Rotation gates(Rx gate, Ry gate and Rz gate), as well as the S gate and T gate.</li>
				<li><b>Two-qubit gates</b>: the Controlled Not gate (CNOT), SWAP gate, Controlled Ration gate, and Controlled Unitary gate.</li>
				<li><b>Multi-qubit gates</b>: the Toffoli gate and Controlled SWAP gate, etc.</li>
			</ul>
			<h3><b>3.2.1 One-qubit Gates</b></h3>
			<p><b>X gate:</b> also known as the Pauli-X gate or quantum Not gate, flips the state of a qubit from |0> to |1> and vice versa.
				It performs the same function as the NOT gate in classical computing, which flips a bit.
				While the classical NOT gate operates on classical bits, the quantum X gate operates on quantum states. </p>
			<p>Because the one-qubit input and output of X gate are represented by vectors, the X gate is expressed as a matrix.
				This matrix representation of the X gate is a concise way to describe the operation performed by the gate on qubits.
			</p>
			<img src="../fig/X.png" id="centerImg">
			<p>Specifically, The matrix of X gate: </p>
			<p>\[X = \begin{pmatrix}
            0 & 1 \\
            1 & 0 \\
            \end{pmatrix}\]</p>
			<p>This matrix shows how the gate flips the basis states |0> and |1>. Understanding the matrix representation of quantum gates can be crucial for predicting the final quantum states after complex quantum circuits have been applied.</p>

			<p>To illustrate how the X gate operates on a qubit, consider an example where X gate is applied to an input qubit \(|\psi>\).</p>
			<p>Suppose the input qubit is in the state: </p>
			<p>\[|\psi> = \alpha|0> + \beta|1>\]</p>
			<p>where \(\alpha\) and \(\beta\) are complex amplitudes of |0> and |1> respectively.</p>


			<p>To find the output state \(\psi'>\) after applying X gate, perform the matrix multiplication of X with
			the vector representation of \(\psi>\): </p>
			<p>\[

				\begin{align}

				|\psi'> &= X|\psi> \\
					&= \begin{pmatrix}
            			0 & 1 \\
            			1 & 0 \\
            			\end{pmatrix} \begin{pmatrix}
            							\alpha \\
            							\beta \\
            						\end{pmatrix} \\
					&= \begin{pmatrix}
            				\beta \\
            				\alpha \\
            			\end{pmatrix} \\
					&= \beta|0> + \alpha|1>

				\end{align}
				\]</p>


			<p>Thus, the outcome state \(|\psi'>\) is:</p>

			<p>\[|\psi'> = \beta|0> + \alpha|1>\]</p>
			<p>This output shows that the X gate flips the amplitude of |0> and |1>.</p>
			<p><b>Y gate:</b> also known the Pauli-Y gate, introduces a phase shift of 180 degrees when applied to |1>, and -180 degrees when applied to |0>. In other words, Y gate flips the basis states and introduces a complex phase shift.</p>
			<img src="../fig/Y.png" id="centerImg">

			<p>The matrix representation of the Y gate is given by: </p>
			<p>\[Y = \begin{pmatrix}
            0 & -i \\
            i & 0 \\
            \end{pmatrix}\]</p>
			

			<p>To illustrate the operation of Y gate on a qubit, consider the input qubit state \(|\psi>\). </p>
			<p>\[|\psi> = \alpha|0> + \beta|1>\]</p>
			<p>After applying Y gate to the input qubit: </p>
			<p>\[
				\begin{align}
					|\psi'> &= Y|\psi> \\
						    &= \begin{pmatrix}
								0 & -i \\
            					i & 0 \\
            					\end{pmatrix} \begin{pmatrix}
            									\alpha \\
            									\beta \\
            								\end{pmatrix}\\
							&= \begin{pmatrix}
            						i\beta \\
            						-i\alpha \\
            					\end{pmatrix} \\
							&= i\beta|0> - i\alpha|1>
				\end{align}
				\]</p>
			
			<p>Thus, the outcome state \(|\psi'>\) is: </p>
			<p>\[|\psi'> = - i\alpha|1> + i\beta|0>\]</p>

			<ul>
				<li>When the input qubit is |0>, it means that \(\alpha\) = 1 and \(\beta\) = 0, the output state is -i|1>.</li>
				<li>When the input qubit is |1>, it means that \(\alpha\) = 0 and \(\beta\) = 1, the output state is i|0>.</li>
			</ul>
			<p><b>Z gate:</b> introduce a phase flip when applied to |1>, and no changing when applied to |0>.</p> 
			<img src="../fig/Z.png" id="centerImg">
			<p>The matrx of Z gate:</p>
			<p>\[Z = \begin{pmatrix}
            1 & 0 \\
            0 & -1 \\
            \end{pmatrix}\]</p>


			<p>For example, Z gate is appled to the input qubit \(|\psi> = \alpha|0> + \beta|1>\), and the output qubit \(|\psi'>\) as follow,</p>
			<p>\[|\psi'> = Z|\psi> = \begin{pmatrix}
            1 & 0 \\
            0 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            \alpha \\
            \beta \\
            \end{pmatrix} = \begin{pmatrix}
            \alpha \\
            -\beta \\
            \end{pmatrix} = \alpha|0> - \beta|1>\]</p>

			<p>The outcome is \(\alpha|0> - \beta|1>\)</p>

			<p><b>Hadamare gate:</b> also called H gate, creates superposition by putting a qubit into an equal probability of being |0> and |1>.</p>
			
			<img src="../fig/H.png" id="centerImg">
			<p> The matrix of H gate:</p>
			<p>\[H = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix}\]</p>


			<p>For example, Z gate is appled to the input qubit |0> and |1> respectively, and the output qubit \(|\psi'>\) as follow,</p>

			<p>\[|\psi'> = H|0> = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            1 \\
            0 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 \\
            1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}(|0> + |1>)\]</p>


			<p>\[|\psi'> = H|1> = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            0 \\
            1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 \\
            -1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}(|0>-|1>)\]</p>


			<p>When the input qubit \(\alpha|0> + \beta|1>\), the output is </p>
			<p>\[
				\begin{align}
				|\psi'> &= H(\alpha|0> + \beta|1>) \\
						&= \alpha(\frac{1}{\sqrt{2}}(|0> + |1>)) + \beta(\frac{1}{\sqrt{2}}(|0> - |1>)) \\
			 			&=\frac{\alpha+\beta}{\sqrt{2}}|0>+\frac{\alpha-\beta}{\sqrt{2}}|1>
				\end{align}
				\]
			</p>
			<p>Here, X, H and Z gate has relations, Z gate obtained by X and H gate,
				and X gate obtained by Z and H gate.
				\[
					X = HZH \\
					Z = HXH
				\]
			</p>
			<p>Reader can verify the relation between X, H and Z gate through linear algebra.</p>
			<p>Rotation X gate: also called Rx gate, performs a rotation around the x-axis of the Bloch sphere. </p>
			<p>The matrix of Rx gate:</p>
			<p>\[R_{x}(\theta) = \begin{pmatrix}
            	\cos\frac{\theta}{2} & -i \sin\frac{\theta}{2} \\
            	-i \sin\frac{\theta}{2} &  \cos\frac{\theta}{2}\\
            \end{pmatrix}\]</p>
			<p>Rotation Y gate: also called Ry gate, performs a rotation around the y-axis of the Bloch sphere. </p>
			<p>The matrix of Ry gate:</p>
			<p>\[R_{y}(\theta) = \begin{pmatrix}
            	\cos\frac{\theta}{2} & -\sin\frac{\theta}{2} \\
            	\sin\frac{\theta}{2} &  \cos\frac{\theta}{2}\\
            \end{pmatrix}\]</p>
			<p>Rotation Z gate: also called Rz gate, performs a rotation around the z-axis of the Bloch sphere. </p>
			<p>The matrix of Rz gate:</p>
			<p>\[R_{z}(\theta) = \begin{pmatrix}
            	e^{-i\frac{\theta}{2}} & 0 \\
            	0 & e^{i\frac{\theta}{2}} \\
            \end{pmatrix}\]</p>

			<p><b>T gate</b>: a rotation about z-axis on the Bloch sphere by \(\frac{\pi}{4}\). </p>

			<p>The matrix of T gate:</p>
			<p>\[
				T = \begin{pmatrix}
            	1 & 0 \\
            	0 & e^{i\frac{\pi}{4}}
				\end{pmatrix}\]</p>

			<h3><b>Two-qubit Gates</b></h3>
			<p><b>CNOT gate:</b> assign one qubit as the role of control qubit and pair it with another as the target qubit. The target qubit flips when the control qubit is in the state |1>, and remain unchanged when the control qubit is in the state |0>. In classical computing, XOR operation can flip the target bit based on the state of the control bit. However, the CNOT gate introduces the superposition and entanglement of quantum mechanics, CNOT gate allows qubits to exist in superposition, representing multiple states simultaneously, and be entangled for quantum parallelism computation. In contrast, XOR gate can only have one of two state at any given time.</p>
			<img src="../fig/CNOT.png" id="centerImg">
			<p>CNOT gate operates the basis state as follows:</p>
			<p id="cnot">CNOT|00> = |00></p>
			<p id="cnot">CNOT|01> = |01></p>
			<p id="cnot">CNOT|10> = |11></p>
			<p id="cnot">CNOT|11> = |10></p>

			<p>The matrix of CNOT gate:</p>
			<p>\[CNOT = \begin{pmatrix}
            1 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1 \\
            0 & 0 & 1 & 0 \\
            \end{pmatrix}\]</p>
			
			
			<p>For example, the input qubit \(|\psi>=\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>\). The output qubit after applying a CNOT gate: </p>
			<div>
				\[
					\begin{align}

						|\psi'> &= CNOT(\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>) \\
								&= \begin{pmatrix}
            						1 & 0 & 0 & 0 \\
            						0 & 1 & 0 & 0 \\
            						0 & 0 & 0 & 1 \\
            						0 & 0 & 1 & 0 \\
            						\end{pmatrix} \begin{pmatrix}
            									  \alpha_{00}\\
            									  \alpha_{01}\\
            									  \alpha_{10}\\
            									  \alpha_{11}\\
												  \end{pmatrix} 
								 = \begin{pmatrix}
									\alpha_{00}\\
                                    \alpha_{01}\\
                                    \alpha_{11}\\
                                    \alpha_{10}\\
            					   \end{pmatrix} \\
							    &=\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|11> + \alpha_{11}|10>
					\end{align}

				\]


			</div>
	</div>
    <div class="container">
		<p><b>SWAP gate:</b> swap the quantum state of two qubits. </p>
		<img src="../fig/SWAP.png" id="centerImg">
		<p>With respect to the basis states, the output state through a swap gate</p>
		<p id="cnot">SWAP|00>=|00></p>
		<p id="cnot">SWAP|01>=|10></p>
		<p id="cnot">SWAP|10>=|01></p>
		<p id="cnot">SWAP|11>=|11></p>
		
		<p>The matrix of SWAP gate:</p>
        <p>\[SWAP = \begin{pmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 1 \\
            0 & 0 & 0 & 1 \\
            \end{pmatrix}\]</p>


		<p>SWAP gate can be decomposed into three CNOT gate. The decomposition as follows:</p>

		<p>\[SWAP = CNOT_{01} \times CNOT_{10} \times CNOT_{01}\]</p>
		<img src="../fig/SWAP_CNOT.png" id="centerImg">

		<p>Here, \(CNOT_{01}\) is a CNOT gate with the first qubit as control qubit and the second as target qubit. \(CNOT_{10}\) is a CNOT gate with the second qubit as control qubit and the first as target qubit. </p>
	
		<p><b>Controlled-U gate:</b> also called CU gate, assign ong qubit as control qubit to determine whether the other qubit is affected by an Unitary gate. CNOT gate is a specific instance of the CU gate, where the Unitary gate is X gate. In a CU gate, the target qubit remains unchanged when the control qubit is in the state |0>, and the Unitary gate operates the target qubit when the control qubit is in the state |1>. Different unitary gate can be used to create different CU gates, allowing for the construction of complex quantum circuits. But note that not arbitary unitary gate can be used to create CU gates. There are certain limitations for constructing CU gates in quantum computing. Now common unitary gates, like X gate, Y gate, Z gate, and Rotation gate, can be appiled to create specific CU gates. In some cases, some unitary gates that can not be directly used to create CU gates can be decomposed into a combination of common unitary gates,  so it is alternative to construct specific CU gates.</p>
		<img src="../fig/CU.png" id="centerImg">
		<p>The matrix of CU gate:</p>
		<div>
			\[
				CU = \begin{pmatrix}
            			I & 0 \\
						0 & U \\
					\end{pmatrix}
			\]
		</div>

		<p>Here, \(I\) is 2 \(\times\) 2 identity matrix, and \(U\) is 2 \(\times\) 2 unitary matrix.</p>

		<p>For example, the Unitary gate in the CU gate is H gate, and the input two-qubit \(|\psi>\). The output qubit after applting the CU gate: </p>
		<div>
			\[
				|\psi> = \alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>
			\]
			
			\[
				\begin{align}
				|\psi'> &= CU|\psi> = \begin{pmatrix}
                        	1 & 0 & 0 & 0 \\
                        	0 & 1 & 0 & 0 \\
                        	0 & 0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
                        	0 & 0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\
                    	\end{pmatrix}\begin{pmatrix}
                                    \alpha_{00}\\
                                    \alpha_{01}\\
                                    \alpha_{11}\\
                                    \alpha_{10}\\
                                   \end{pmatrix} \\
					   & = \begin{pmatrix}
                                    \alpha_{00}\\
                                    \alpha_{01}\\
                                    \frac{\alpha_{10}+\alpha_{11}}{\sqrt{2}}\\
                                    \frac{\alpha_{10}-\alpha_{11}}{\sqrt{2}}\\
                           \end{pmatrix} \\
					   &= \alpha_{00}|00> + \alpha_{01}|01> + \frac{\alpha_{10}+\alpha_{11}}{\sqrt{2}} + \frac{\alpha_{10}-\alpha_{11}}{\sqrt{2}}|11>\\
				\end{align}
			\]
		</div>



		<h3>Three-qubit Gates</h3>
		<p><b>Toffoli gate:</b> also called CCNOT gate, assign two qubits as control qubit and another qubit as target qubit. The target qubit flips when both control qubits are in the state |1>, and otherwise the target qubit remains unchanged.</p>
		<img src="../fig/CCNOT.png" id="centerImg">
		<p>The matrix of Toffoli gate or CCNOT gate(the first and second qubit as control qubits and the third qubit as target qubit):</p>
		<p>\[CCNOT = \begin{pmatrix}
            1 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 1 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 1 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 1 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 1 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 1\\
            0 & 0 & 0 & 0 & 0 & 1 & 0\\
            \end{pmatrix}\]</p>
		<p></p>
	


	</div>

	</section>


	<section id="about" class="about">
		<div class="container">			
			<h2>3.3 Quantum Circuits</h2>
			<p>Quantum circuit is a computation model that utilizes a combination of quantum gates to perform quantum operations on qubits. Quantum gates manipulate the quantum state of input qubits, leading to a final state that represents the computation's outcome. These outcomes are probabilistic so requires multiple measurements are required to obtain final results. One property of quantum circuits is reversiblility. This arises from the fact that each quantum gate is unitary, imply that the input state can be recovered from the output qubits using some unitary gates. The nature of quantum gates ensures that the evolution of the quantum state is traceable in both forward and backward directions.</p>

			<p>Understanding quantum circuits are easy for individuals with a background in classical digital circuits.
				Both classical and quantum circuits follow the rule of bit or qubit from input to output through quantum gates.
				The different is that qubits have superposition, leading different quantum states exists at the same.
			</p>
			<p>There are comparasion between classical and quantum circuits.</p>
			<p>1. Basic circuit composition:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: AND, OR, NOT, and XOR gates that perform classical Boolean operations on bits.</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: X, Y, Z, CNOT gates, etc, that acts quantum bits.</p>
			<p>2. Flow of Circuits:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: information flows through classical bits.</p>
			<p><span class="large-bullet">&#9642;</span>Quantum circuits: information flows through qubits.</p>
			<p>3. Mathematical Model:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: Boolean algebra is used to represent bits and handle computation.</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: unitary vectors are represented quantum states and unitary matrix as quantum gates. Linear algebra is used to describe the procedure of quantum circuits.</p>
			<p>4. Superposition:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: process one bit at one time</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: allow for the parallel manipulation of multiple quantum states becaues of the principles of superposition and entanglement.</p>
			<p></p>

			<h3>3.3.1 A quantum circuit</h3>
			<p>A simple quantum circuit from the book, "Classical and Quantum Information Theory: An Introduction for the Telecom Scientist"[1],
				is as an example to explain the flow of quantum circuits. Similar to classical circuits,
				the progression unfolds from right to left, with each step involving the execution of quantum gates on qubits.</p>

			<img src="../fig/Circuit.png" id="centerImg">
			<p>
				When |a> = |0>,
				\[ |0>|x> \xrightarrow{CU} |0>|x> \xrightarrow{XA} X|0>A|x> = |1>A|x> \xrightarrow{CU'}
					|1>U'A|x> \]
				When |a> = |1>,
				\[ |1>|x> \xrightarrow{CU} |1>U|x> \xrightarrow{XA} X|1>AU|x> = |0>AU|x> \xrightarrow{CU'}
					|0>AU|x> \]
				When |a> = \(\alpha|0> + \beta|1>\),
					\[ \alpha|0>|x> + \beta|1>|x> \xrightarrow{}  \alpha|1>U'A|x> + \beta|0>AU|x>\]
			</p>

			<div>
				<h3><b>3.3.2 Quantum circuit for bell states</b></h3>
				<p>A Bell state, also called as an entangled state or EPR pair(Einsten-Podolsky-Rosen pair), is a specific
					entangled quantum states of two qubits. John Bell introduced Bell inequalities that was designed to test
					the entangled part of the property of quantum mechanics. The Bell states can be constructed through
					the quantum circuits as follows. When some entanged qubits are prepared, the Bell quantum circuit can be applied into customed quantum circuits.
				</p>
				<img src="../fig/BellCircuit.png" id="centerImg">
				<p>When the input qubit |q0> = |0> and |q1> = |0>, </p>
				<div>
					\[
						|0>|0> \xrightarrow{H_{0}} H|0>|0> = \frac{1}{\sqrt{2}}(|0>+|1>)|0> \xrightarrow{CNOT_{01}}
						\frac{1}{\sqrt{2}}(|00> + |11>)
					\]
				</div>
				<p>The output qubit is \(\frac{1}{\sqrt{2}}(|00> + |11>)\)</p>
				<p>In fact, there are four types of Bell states. Another three types as follows:</p>
				<div>
					\[
						\beta_{01} = \frac{1}{\sqrt{2}}(|01> + |10>) \\
						\beta_{10} = \frac{1}{\sqrt{2}}(|00> - |11>) \\
						\beta_{11} = \frac{1}{\sqrt{2}}(|01> - |10>)
					\]
					<p>It means that the input qubits are |01>, |10> and |11> respectively in the quantum circuit above.</p>
				</div>
			</div>
			<h3>3.3.3 Toffoli Gate</h3>
			<p>Toffoli Gate: includes H gate, T gate, \(T^\dagger\) gate and CNOT gate.</p>
			<img src="../fig/Toffoli_n.png" id="centerImg">
			<p>The quantum circuit equals Toffoli gate.</p>

			<h3><b>3.3.4 Quantum full adder</b></h3>

			<p>The add cirucit use CNOT and CCNOT circuits so it is important to know the output state of the target qubit of CNOT and CCNOT.</p>
			<p>CNOT gate acts on two qubits, A as control qubit and B as target qubit. </p>
			<p>The output state of CNOT = \(|A>|A \oplus B>\)</p>
			<p>	It is easy to verify it through true table.
				When A is |0> as control qubit, the output of B(target qubit) is unchanged.
				When A is |1> as control qubit, the output state of B(target qubit) flips.
				Therefore, the output state of target is XOR between the state of A and B.
			</p>
			<p>CCNOT gate acts on three qubits, A and B as control qubits and C as target qubit.</p>
			<p>The output state of CCNOT = \(|(A \cdot B) \oplus C>\)</p>
			<p>We can see A and B as one qubit(\(A \cdot B\)) to control the target qubit so it is the same as CNOT gate.</p>

			<p>The quantum circuit of full adder as follows:</p>
			<img src="../fig/Adder.png" id="centerImg">
			<p>We derive the math expression of \(C_{out}\) and S seperately. </p>
			<p></p>
			<div>In the stage 1,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |B> \\
					|C_{out}> &= |(AB) \oplus 0> = |AB>
					\end{align}
				\]
			</div>
			<div>
				In the state 2,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |(AB) \oplus 0> = |AB>
					\end{align}
				\]
			</div>
			<div>
				In the stage 3,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}
				\]

				In the stage 4,

					\begin{align}
					|S> &= |C_{in} \oplus A \oplus B> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}

				In the final stage,
					\begin{align}
					|S> &= |C_{in} \oplus A \oplus B> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}
				<p>From the equation above, we can see the expression state of |S> equals the math one of S of a full adder.</p>

				<p>However, the expression of \(C_{out}\) is different from the one of a full adder. We can simply the expression to verify that they are the same one.</p>
				<div>
					\[
						\begin{align}
							|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
						\end{align}
					\]
					We can use X represents \(A \oplus B\), then


					\[
						\begin{align}

							|C_{out}> &= |AB \oplus [C_{in} \cdot X]> \\
									  &= |AB \overline{C_{in}X} + \overline{AB} C_{in}X>\\
									  &= |AB(\overline{C_{in}} + \overline{X}) + (\overline{A}+\overline{B})C_{in}X> \\
									  &= |AB(\overline{C_{in}} + \overline{A\oplus B}) + (\overline{A}+\overline{B})C_{in}\overline{A\oplus B})> \\
									  &= |AB(\overline{C_{in}} + AB + \overline{A}\overline{B}) + (\overline{A}+\overline{B})(A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB\overline{C_{in}} + AB + (A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB + (A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB + (A\oplus B) \cdot C_{in}>
						\end{align}

					\]
					<p>We can see the expression of \(|C_{out}>\) equals the \(C_{out}\) of a full adder.
						Therefore, the quantum full adder circuit can have the function of adding two qubits with carry.</p>
				</div>
			</div>

			<p>For example, before we use the quantum full adder, we need to prepare the input qubit for
				the value we want to compute. For example, when A = 0, B = 0, Cin = 1 and A = 1, B = 1, Cin = 1, we need
				to design quantum circuit to satisfy the condition. I used qiskit simulator to make
				the quantum circuit and got the measurement outcome of the circuit. The quantum circuit as follows:</p>
			<img src="../fig/adder_preparation_qiskit1.png" id="centerImg">

			<img src="../fig/adder_preparation_qiskit2.png" id="centerImg">
			<p>The first qubit |q0> is Cin, the second |q2> and third qubits |q3> are A and B, the last qubit |q4> is |0> as the input qubits.
				We prepared input quantum states, one is |A> = |B> = |0>,  |Cin> = |1>, and the other is |A> = |B> = |1>, |Cin> = |1>.
				In Qiskit, note the first qubit is the rightest one in the figure.
				The outcome in the figure is |0001> with the probability with 677/1024, and |0111> with 347/1024.

			</p>
			<img src="../fig/adder_qiskit1.png" id="centerImg">
			<img src="../fig/adder_qiskit2.png" id="centerImg">
			<p>In the figure, from the right to left, the first qubit of the final result is the sum of A and B, the second and third one are A and B,
				and the last one is the carry. </p>
			<p>In the figure, |0001> represents the carry is 0 and the sum of A and B is 1 when A = B = 0, and Cin = 1.
				Its probability is 653/1024 which is close to 677/1024.
				|1111> represents the carray is the carry is 1 and the sum of A and B is 1 when A = B = 1, and Cin = 1.
				Its probability is 371/1024 which is close to 647/1024.
				It means that the quantum circuit can perform the function of a full adder.
			</p>

			<p></p>
			<p>The preceding illustration described a one bit full adder. Now, consider the figure below,
			representing a two bit full adder composed of two such one bit adders, such as A = 01 and B = |11>.
				This conceptual framework
			can be extended to design quantum adders for systems involving multiple bits.</p>

			<img src="../fig/Adder_N.png" id="centerImg">
			<p>When 01 and 11 are as the input of a two bit full adder, it means that |A0> = |1>,
			|A1> = |0>, |B> = |1>, and |B>=|1>. The Cout of first adder is as the input Cin of the second adder.
				The output of |S0>, |S1>, and |Cout> represent the first bit and the second bit of Sum (from right to left),
			and the carry bit value. The sum of 01 and 11 equals 100 so |S0> = |0>, |S1 > = |0> and |Cout> = |1>.</p>

			<p>
				When multiple qubits add respectively, it only prepares the input qubits in superposition.
				When the sum of the 11 and 01, it prepares |A0> = |1>, |A1> = |1>, |B0> = |1>, and |B1> = |0>.
				when the sum of the 00 and 10, it prepares |A0> = |0>, |A1> = |0>, |B0> = |0>, and |B1> = |1>.

				Therefore, |A0>|B0>|A1>|B1> needs to be |1110> and |0001> in the superposition.
				<img src="../fig/two_bit_adder1.png" id="centerImg">
				<img src="../fig/two_bit_adder2.png" id="centerImg">
				<img src="../fig/two_bit_adder3.png" id="centerImg">
			</p>
			<p>From the outcome of qiskit, qubits are in the superposition with |01100100> and |0000010>(from the right to left in the figure).
				It illustrates that |A0>|B0>|A1>|B1> is in |1110> and |0001> with the probability of 326/1024 and 698/1024 respectively.
			</p>

			<img src="../fig/two_bit_adder.png" id="centerImg">
			<img src="../fig/two_bit_adder5.png" id="centerImg">
			<p>The outcome |S0>|A0>|B0>|S1>|A1>|B1>|Cout> in the figure is |0001010> and |0110101>(from the right to left in the figure).</p>
			<p>	|0001010> is |S0> = |0>, |A0> = |0>, |B0> = |0>, |S1> = |1>, |A1> = |0>, |B1> = |1>, |Cout> = |0>, so it means
				the sum of 00 and 10 equals 010.</p>
			<p>	|0110101> is |S0> = |0>, |A0> = |1>, |B0> = |1>, |S1> = |0>, |A1> = |1>, |B1> = |0>, |Cout> = |1>, so it means
				the sum of 11 and 01 equals 100.
			</p>

			<h3><a>3.3.5 Quantum binary multiplication</a></h3>
			The method is from the paper[2] that introduce the detailed process of constructing quantum multiplication.
			In classical multiplication, each digital of one number A is multiplied by each digital of another number B, and then
			add up the results according to their place values.
			<p></p>
			<img src="../fig/Multiplication.png" id="centerImg">

			<p>The method of quantum multiplication is to construct two binary number multiplication and full adder. The binary numbers A and B
				are represented using qubits. Toffoli gate is used to perform multiplication computation between qubits.
				After multiplication, the results are added together using a quantum full adder. For example, firstly, the binary numbers A(\(A_3A_2A_1A_0\)) and B(\(B_3B_2B_1B_0\))
				are encoded by qubits. In the second step, \(B_3A_0\), \(B_2A_0\), \(B_1A_0\), and \(B_0A_0\) are constructed respectively, then
				the results are added together. The second step is continued to perform repeatedly until all the binary number of A and B are computed.
			</p>
			<img src="../fig/multiplication_qubit.png" id="centerImg">
			<p>In the blue part of the figure, Ai and B0 ... Bn-1 are multiplied respectively using Toffoli gates.
				In the red part of the figure, a full adder is used to add the outputs of C0 and C1. In the yellow part,
				the C0 is recovered to the quantum states |000>. This is because it needs to continue to perform Ai and B0 ... Bn-1 multiplication.
			</p>
			<p>For example, I built a quantum circuit to multiple two numbers mod \(2^3\) with the binary length of 3. The first three qubits (q0, q1, q2) encode A,
			qubits (q3, q4, q5) encodes 8, qubits (q6, q7, q8) represents \(A_i * B_j\), qubits (q9, q10, q11) represents A0 * B0, A0 * B1, A0 * B2,
			qubits (12, 13, 14) represents the sum of the first addition(A0*B2 A0*B1 A0*B0 + A1*B1 A1*B0), qubit q15 represents the carry,
			qubits (16, 17, 18) represents the sum of the second addition (qubits(12, 13, 14) + A2*B0), qubit 19 represents the carry.
			The final result is qubits (16, 17, 18), the carry deleted because it needs to mod 8. </p>
			<img src="../fig/multiplication_qiskit_1.png" id="centerImg">
			<img src="../fig/multiplication_qiskit_2.png" id="centerImg">
			<img src="../fig/multiplication_qiskit_3.png" id="centerImg">

			<p>Qiskit example lists A and B range from 0 and 15 and the final results mod 8. It requires the number of qubits </p>
			<div>
				\[2 * L_{a} + 2 * L_{c} + 2 * (L_{c} + 1)\]
			</div>
			<p>\(L_a\) represents the length of the encoding binary string of A or B.
			\(L_c\) represents the length of the encoding binary string of the final result. In the example, \(L_a\) and \(Lc\) are 3 so the length of
				qubits is 20.</p>
			<p></p>

			<h3>Reference</h3>
			<p>1. Desurvire, Emmanuel. (2009). Classical and Quantum Information Theory: An Introduction for the Telecom Scientist. 10.1017/CBO9780511803758. </p>
			<p>2. Cho, S. M., Kim, A., Choi, D., Choi, B. S., & Seo, S. H. (2020).
				Quantum modular multiplication. IEEE Access, 8, 213244-213252.</p>
		</div>
	</section>



    <section id="contact" class="contact">
        <div class="container">
            <h2>Contact Me</h2>
            <p>Email: tankzhang19@gmail.com</p>
            <p>LinkedIn: linkedin.com/in/zhang-hongfeng-176122270/</p>
            <!-- Add more contact information as needed -->
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2023 Hongfeng Zhang</p>
        </div>
    </footer>

</body>
</html>

