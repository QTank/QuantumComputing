<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <title>Quantum Computing</title>
	<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

	<style>
        #centerImg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: auto;
        }

		#cnot {
			text-align: center;
		}

		.cnotContainer {
            display: flex;
        }

        .box {
			margin-right: 10px; /* Adjust the margin between divs as needed */
            display: inline-block; /
			background-color: #fff; /* Set background color as needed */
        }
    </style>

</head>


<body>

<!--    <header onclick="window.location.href = '../index.html';">-->
<!--    	<h1>Hongfeng Zhang</h1>-->
<!--	</header>-->

    <nav>
        <div class="container">
            <ul>
<!--                <li><a href="#Post">Post</a></li>-->
				<li><a href="../index.html">Home</a></li>
                <li><a href="../Research.html">Research</a></li>
                <li><a href="../Learn.html">Learn</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </nav>
		<section id="about" class="about">
        <div class="container">
			<h1 id="chapter">Chapter 3 Quantum Circuit</h1>
			<h2>3. 1 Quantum Bit</h2>
			<p>In classical computing, a bit is the fundamental unit of information and the basic building block of digital data. A bit can represent one of two states, typically expressed as 0 or 1. Electronic devices, such as transistors in computer circuits, can easily build two states(high/low voltage), making it a natural choice for encoding information in digital systems. The manipulation of bits forms the foudation of digital computation and information processing in classical computers</p>
			<p>In quantum computing, a quantum bit is the fundamental unit of quantum informationin quantum computing, also called qubit. Unlike classical bits which can only be certain in a state of 0 or 1, a qubit posseses the unique property of existing in both 0 and 1 simultaneously. This property is called as superposition. Upon measurement, the superposition collapses, and the qubit takes on a definte state either 0 or 1. The outcome is probablisstic, introducing an element of uncertainty. The probablities assigned during the superpostion influence the likelihood of the qubit collapsing into either state.</p>
			
			<p>In quantum information theory, a quantum state is noted as |\(\psi\)>. The quantum state 0 is noted as |0>, and the quantum state 1 is noted as |1>.
				A qubit can exist both quantum state 0 and 1, so it uses a two-dimensional vector to represent a qubit rather than a number like classical bit.
				The first number in the vector represents the state 0 and the other represents the state 1.
				In a math model, the quantum state 0 or 1 is the specific one, called computational basis states,
				such as
	|0> = \(\begin{pmatrix}
			1 \\
			0
			\end{pmatrix}\) 
and |1| = \(\begin{pmatrix}
			0\\
			1
			\end{pmatrix} \). This is the most simple one to represent a qubit. All orthogonal vector can be used to represent a qubit.
				For example, |0> = \(\begin{pmatrix}
			\frac{1}{\sqrt{2}} \\
			\frac{1}{\sqrt{2}}
			\end{pmatrix}\)  and |1> = \(\begin{pmatrix}
			\frac{1}{\sqrt{2}} \\
			-\frac{1}{\sqrt{2}}
			\end{pmatrix}\). But this one is a more complex than the first one in most situation.  \(\)
			A qubit can be represented by a line superpostion of two elementary orthogonal states |0> and |1>:</p>

			<p id="eq1">\[|\psi> = \alpha|0> + \beta|1> = \alpha \begin{pmatrix}
            1 \\
            0
            \end{pmatrix} + \beta \begin{pmatrix}
            0 \\
            1
            \end{pmatrix} = \begin{pmatrix}
            \alpha \\
            \beta
            \end{pmatrix}\]</p>
			<p>The two coordinates \(\alpha\) and \(\beta\) are called qubit amplitudes. A measurement is not deterministic, but the total probabilites of all quantum states are certain to equal 1. When a qubit system is measured, the probability of yielding the quantum state 0 equals \(|\alpha|^{2}\), and that of yielding the quantum state 1 equals \(|\beta|^{2}\). Therefore we have</p> 
			<p>\[|\alpha|^{2} + |\beta|^{2} = 1\]</p>


			</p>


			<p>In a multi-qubit system, the state of the entire system is described by the combined quantum states of each qubit.
				The state of the n-qubit system is represented as a linear combination of basis states.
				The \(2^n\) dimensional vector can be used as the quantum state of a n-qubit quantum systm.
			<p>\[
					|\psi> = \begin{pmatrix}
            				\alpha_{0} \\
							\alpha_{1} \\

							\vdots \\
            				\alpha_{2^n - 1} \\
							\end{pmatrix}
				\]</p>
			<p>Here, \(\alpha_{0}\) represents the amplitude of the quantum state \(|000....000>\)(binary representation with n bit of the number 0),
				\(\alpha_{2^n-1}\) represents the amplitude of the quantum state \(|111....111>\)(binary representation with n bit of the number \(2^n-1\))</p>



			<p>	In a 2-qubit system, the basis state |00>, |01>, |10>, and |11> can be denoted as a vector:</p>
			<p>\[|00> = \begin{pmatrix}
            1 \\
            0 \\
            0 \\
            0 \\
            \end{pmatrix}, |01> = \begin{pmatrix}
            0 \\
            1 \\
            0 \\
            0 \\
            \end{pmatrix}, |10> = \begin{pmatrix}
            0 \\
            0 \\
            1 \\
            0 \\
            \end{pmatrix}, |11> = \begin{pmatrix}
            0 \\
            0 \\
            0 \\
            1 \\
            \end{pmatrix} \]</p> 


A qubit in a 2-qubit system can be in a superposition of four basis states:</p>
			<p>\[|\psi> = \alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11> = \begin{pmatrix}
            \alpha_{00} \\
            \alpha_{01} \\
            \alpha_{10} \\
            \alpha_{11} \\
            \end{pmatrix}\]</p>
			<p>Here, \(\alpha_{00}, \alpha_{01}, \alpha_{10}\), and \(\alpha_{11}\) are quantum amplitudes of |00>, |01>, |10>, and |11>,</p>

			<p>\[|\alpha_{00}|^{2} + |\alpha_{01}|^{2} + |\alpha_{10}|^{2} + |\alpha_{11}|^{2} = 1\]</p>
	</div>
        </section>

		<section id="about" class="about">
		<div class="container">
			<h2>3. 2 Quantum Logic Gates</h2>
			<p>Quantum logic Gates, also called quantum gates, are fundamental components in the field of quantum computing. Similar to classical gates, quantum gates are building for constructing quantum circuits.
				These gates manipulate quantum bits, from one quantum state \(|\psi>\) to another state \(|\psi'>\).
				For example, a quantum gate called U, and the relation between the input quantum state and output state can be expressed </p>
			<p>\[|\psi'> = U|\psi>\]</p>
			<p>Here, the quantum state \(|\psi>\) and \(|\psi'>\) are both a unitary vetor so the U is a unitaroy operator,
				which is the most imporant property of quantum gates. Please note it. Quantum gates are represented
				by unitary matrices. The common types of quantum gates include one-qubit gates, two-qubit gates, and multiple-qubit gates.
				One-qubit gates include Pauli gates(X gate, Y gate and Z gate), Rotation gates(Rx gate, Ry gate and Rz gate),
				S gate and T gate. Two-qubit gates include Controlled Not gate, SWAP gate, Controlled Ration gate, and Controlled Unitary gate. Multiple gates include
				Toffoli gate and Controlled SWAP gate.
			</p>
			<h3><b>One-qubit Gates</b></h3>
			<p><b>X gate:</b> flip the state of a qubit from |0> to |1> and vice versa. It has the same function as the not gate in classical computing to flip a bit.
				Here, the difference is that quantum X gate flips quantum states. Because the one-qubit input and output of X gate are represented by vectors, the expression of Gate is a matrix.
				Matrix of a quantum gate is a concise way to represent the operation on qubits.
				The expression of quantum gates can help predicting the final quantum states after complex quantum circuits perform.</p>
			<img src="../fig/X.png" id="centerImg">
			<p>The matrix of X gate: </p>
			<p>\[X = \begin{pmatrix}
            0 & 1 \\
            1 & 0 \\
            \end{pmatrix}\]</p>

			<p>For example, X gate is appled to the input qubit \(|\psi> = \alpha|0> + \beta|1>\), and the output qubit \(|\psi'>\) as follow,</p>
			<p>\[|\psi'> = X|\psi> = \begin{pmatrix}
            0 & 1 \\
            1 & 0 \\
            \end{pmatrix} \begin{pmatrix}
            \alpha \\
            \beta \\
            \end{pmatrix} = \begin{pmatrix}
            \beta \\
            \alpha \\
            \end{pmatrix} = \beta|0> + \alpha|1>\]</p>

			<p>The outcome is \(\beta|0> + \alpha|1>\)</p>


			<p><b>Y gate:</b> introduce a phase shift of 180 degrees when applied to |1>, and -180 degrees when applied to |0>.</p> 
			<img src="../fig/Y.png" id="centerImg">
			<p>The matrix of Y gate: </p>
			<p>\[Y = \begin{pmatrix}
            0 & -i \\
            i & 0 \\
            \end{pmatrix}\]</p>
			
			<p>For example, Y gate is appled to the input qubit \(|\psi> = \alpha|0> + \beta|1>\), and the output qubit \(|\psi'>\) as follow,</p>
			<p>\[|\psi'> = Y|\psi> = \begin{pmatrix}
            0 & -i \\
            i & 0 \\
            \end{pmatrix} \begin{pmatrix}
            \alpha \\
            \beta \\
            \end{pmatrix} = \begin{pmatrix}
            i\beta \\
            -i\alpha \\
            \end{pmatrix} = i\beta|0> - i\alpha|1>\]</p>
			
			<p>The outcome is \(i\beta|0> - i\alpha|1>\)</p>



			<p><b>Z gate:</b> introduce a phase flip when applied to |1>, and no changing when applied to |0>.</p> 
			<img src="../fig/Z.png" id="centerImg">
			<p>The matrx of Z gate:</p>
			<p>\[Z = \begin{pmatrix}
            1 & 0 \\
            0 & -1 \\
            \end{pmatrix}\]</p>


			<p>For example, Z gate is appled to the input qubit \(|\psi> = \alpha|0> + \beta|1>\), and the output qubit \(|\psi'>\) as follow,</p>
			<p>\[|\psi'> = Z|\psi> = \begin{pmatrix}
            1 & 0 \\
            0 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            \alpha \\
            \beta \\
            \end{pmatrix} = \begin{pmatrix}
            \alpha \\
            -\beta \\
            \end{pmatrix} = \alpha|0> - \beta|1>\]</p>

			<p>The outcome is \(\alpha|0> - \beta|1>\)</p>

			<p><b>Hadamare gate:</b> also called H gate, creates superposition by putting a qubit into an equal probability of being |0> and |1>.</p>
			
			<img src="../fig/H.png" id="centerImg">
			<p> The matrix of H gate:</p>
			<p>\[H = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix}\]</p>


			<p>For example, Z gate is appled to the input qubit |0> and |1> respectively, and the output qubit \(|\psi'>\) as follow,</p>

			<p>\[|\psi'> = H|0> = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            1 \\
            0 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 \\
            1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}(|0> + |1>)\]</p>


			<p>\[|\psi'> = H|1> = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 & 1 \\
            1 & -1 \\
            \end{pmatrix} \begin{pmatrix}
            0 \\
            1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}\begin{pmatrix}
            1 \\
            -1 \\
            \end{pmatrix} = \frac{1}{\sqrt{2}}(|0>-|1>)\]</p>


			<p>When the input qubit \(\alpha|0> + \beta|1>\), the output is </p>
			<p>\[
				\begin{align}
				|\psi'> &= H(\alpha|0> + \beta|1>) \\
						&= \alpha(\frac{1}{\sqrt{2}}(|0> + |1>)) + \beta(\frac{1}{\sqrt{2}}(|0> - |1>)) \\
			 			&=\frac{\alpha+\beta}{\sqrt{2}}|0>+\frac{\alpha-\beta}{\sqrt{2}}|1>
				\end{align}
				\]
			</p>
			<p>Here, X, H and Z gate has relations, Z gate obtained by X and H gate,
				and X gate obtained by Z and H gate.
				\[
					X = HZH \\
					Z = HXH
				\]
			</p>
			<p>Reader can verify the relation between X, H and Z gate through linear algebra.</p>
			<p>Rotation X gate: also called Rx gate, performs a rotation around the x-axis of the Bloch sphere. </p>
			<p>The matrix of Rx gate:</p>
			<p>\[R_{x}(\theta) = \begin{pmatrix}
            	\cos\frac{\theta}{2} & -i \sin\frac{\theta}{2} \\
            	-i \sin\frac{\theta}{2} &  \cos\frac{\theta}{2}\\
            \end{pmatrix}\]</p>
			<p>Rotation Y gate: also called Ry gate, performs a rotation around the y-axis of the Bloch sphere. </p>
			<p>The matrix of Ry gate:</p>
			<p>\[R_{y}(\theta) = \begin{pmatrix}
            	\cos\frac{\theta}{2} & -\sin\frac{\theta}{2} \\
            	\sin\frac{\theta}{2} &  \cos\frac{\theta}{2}\\
            \end{pmatrix}\]</p>
			<p>Rotation Z gate: also called Rz gate, performs a rotation around the z-axis of the Bloch sphere. </p>
			<p>The matrix of Rz gate:</p>
			<p>\[R_{z}(\theta) = \begin{pmatrix}
            	e^{-i\frac{\theta}{2}} & 0 \\
            	0 & e^{i\frac{\theta}{2}} \\
            \end{pmatrix}\]</p>

			<p><b>T gate</b>: a rotation about z-axis on the Bloch sphere by \(\frac{\pi}{4}\). </p>

			<p>The matrix of T gate:</p>
			<p>\[
				T = \begin{pmatrix}
            	1 & 0 \\
            	0 & e^{i\frac{\pi}{4}}
				\end{pmatrix}\]</p>

			<h3><b>Two-qubit Gates</b></h3>
			<p><b>CNOT gate:</b> assign one qubit as the role of control qubit and pair it with another as the target qubit. The target qubit flips when the control qubit is in the state |1>, and remain unchanged when the control qubit is in the state |0>. In classical computing, XOR operation can flip the target bit based on the state of the control bit. However, the CNOT gate introduces the superposition and entanglement of quantum mechanics, CNOT gate allows qubits to exist in superposition, representing multiple states simultaneously, and be entangled for quantum parallelism computation. In contrast, XOR gate can only have one of two state at any given time.</p>
			<img src="../fig/CNOT.png" id="centerImg">
			<p>CNOT gate operates the basis state as follows:</p>
			<p id="cnot">CNOT|00> = |00></p>
			<p id="cnot">CNOT|01> = |01></p>
			<p id="cnot">CNOT|10> = |11></p>
			<p id="cnot">CNOT|11> = |10></p>

			<p>The matrix of CNOT gate:</p>
			<p>\[CNOT = \begin{pmatrix}
            1 & 0 & 0 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1 \\
            0 & 0 & 1 & 0 \\
            \end{pmatrix}\]</p>
			
			
			<p>For example, the input qubit \(|\psi>=\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>\). The output qubit after applying a CNOT gate: </p>
			<div>
				\[
					\begin{align}

						|\psi'> &= CNOT(\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>) \\
								&= \begin{pmatrix}
            						1 & 0 & 0 & 0 \\
            						0 & 1 & 0 & 0 \\
            						0 & 0 & 0 & 1 \\
            						0 & 0 & 1 & 0 \\
            						\end{pmatrix} \begin{pmatrix}
            									  \alpha_{00}\\
            									  \alpha_{01}\\
            									  \alpha_{10}\\
            									  \alpha_{11}\\
												  \end{pmatrix} 
								 = \begin{pmatrix}
									\alpha_{00}\\
                                    \alpha_{01}\\
                                    \alpha_{11}\\
                                    \alpha_{10}\\
            					   \end{pmatrix} \\
							    &=\alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|11> + \alpha_{11}|10>
					\end{align}

				\]


			</div>
	</div>
    <div class="container">
		<p><b>SWAP gate:</b> swap the quantum state of two qubits. </p>
		<img src="../fig/SWAP.png" id="centerImg">
		<p>With respect to the basis states, the output state through a swap gate</p>
		<p id="cnot">SWAP|00>=|00></p>
		<p id="cnot">SWAP|01>=|10></p>
		<p id="cnot">SWAP|10>=|01></p>
		<p id="cnot">SWAP|11>=|11></p>
		
		<p>The matrix of SWAP gate:</p>
        <p>\[SWAP = \begin{pmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 1 \\
            0 & 0 & 0 & 1 \\
            \end{pmatrix}\]</p>


		<p>SWAP gate can be decomposed into three CNOT gate. The decomposition as follows:</p>

		<p>\[SWAP = CNOT_{01} \times CNOT_{10} \times CNOT_{01}\]</p>
		<img src="../fig/SWAP_CNOT.png" id="centerImg">

		<p>Here, \(CNOT_{01}\) is a CNOT gate with the first qubit as control qubit and the second as target qubit. \(CNOT_{10}\) is a CNOT gate with the second qubit as control qubit and the first as target qubit. </p>
	
		<p><b>Controlled-U gate:</b> also called CU gate, assign ong qubit as control qubit to determine whether the other qubit is affected by an Unitary gate. CNOT gate is a specific instance of the CU gate, where the Unitary gate is X gate. In a CU gate, the target qubit remains unchanged when the control qubit is in the state |0>, and the Unitary gate operates the target qubit when the control qubit is in the state |1>. Different unitary gate can be used to create different CU gates, allowing for the construction of complex quantum circuits. But note that not arbitary unitary gate can be used to create CU gates. There are certain limitations for constructing CU gates in quantum computing. Now common unitary gates, like X gate, Y gate, Z gate, and Rotation gate, can be appiled to create specific CU gates. In some cases, some unitary gates that can not be directly used to create CU gates can be decomposed into a combination of common unitary gates,  so it is alternative to construct specific CU gates.</p>
		<img src="../fig/CU.png" id="centerImg">
		<p>The matrix of CU gate:</p>
		<div>
			\[
				CU = \begin{pmatrix}
            			I & 0 \\
						0 & U \\
					\end{pmatrix}
			\]
		</div>

		<p>Here, \(I\) is 2 \(\times\) 2 identity matrix, and \(U\) is 2 \(\times\) 2 unitary matrix.</p>

		<p>For example, the Unitary gate in the CU gate is H gate, and the input two-qubit \(|\psi>\). The output qubit after applting the CU gate: </p>
		<div>
			\[
				|\psi> = \alpha_{00}|00> + \alpha_{01}|01> + \alpha_{10}|10> + \alpha_{11}|11>
			\]
			
			\[
				\begin{align}
				|\psi'> &= CU|\psi> = \begin{pmatrix}
                        	1 & 0 & 0 & 0 \\
                        	0 & 1 & 0 & 0 \\
                        	0 & 0 & \frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\
                        	0 & 0 & \frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}} \\
                    	\end{pmatrix}\begin{pmatrix}
                                    \alpha_{00}\\
                                    \alpha_{01}\\
                                    \alpha_{11}\\
                                    \alpha_{10}\\
                                   \end{pmatrix} \\
					   & = \begin{pmatrix}
                                    \alpha_{00}\\
                                    \alpha_{01}\\
                                    \frac{\alpha_{10}+\alpha_{11}}{\sqrt{2}}\\
                                    \frac{\alpha_{10}-\alpha_{11}}{\sqrt{2}}\\
                           \end{pmatrix} \\
					   &= \alpha_{00}|00> + \alpha_{01}|01> + \frac{\alpha_{10}+\alpha_{11}}{\sqrt{2}} + \frac{\alpha_{10}-\alpha_{11}}{\sqrt{2}}|11>\\
				\end{align}
			\]
		</div>



		<h3>Three-qubit Gates</h3>
		<p><b>Toffoli gate:</b> also called CCNOT gate, assign two qubits as control qubit and another qubit as target qubit. The target qubit flips when both control qubits are in the state |1>, and otherwise the target qubit remains unchanged.</p>
		<img src="../fig/CCNOT.png" id="centerImg">
		<p>The matrix of Toffoli gate or CCNOT gate(the first and second qubit as control qubits and the third qubit as target qubit):</p>
		<p>\[CCNOT = \begin{pmatrix}
            1 & 0 & 0 & 0 & 0 & 0 & 0\\
            0 & 1 & 0 & 0 & 0 & 0 & 0\\
            0 & 0 & 1 & 0 & 0 & 0 & 0\\
            0 & 0 & 0 & 1 & 0 & 0 & 0\\
            0 & 0 & 0 & 0 & 1 & 0 & 0\\
            0 & 0 & 0 & 0 & 0 & 1 & 0\\
            0 & 0 & 0 & 0 & 0 & 0 & 1\\
            0 & 0 & 0 & 0 & 0 & 1 & 0\\
            \end{pmatrix}\]</p>
		<p></p>
	


	</div>

	</section>


	<section id="about" class="about">
		<div class="container">			
			<h2>3.3 Quantum Circuits</h2>
			<p>Quantum circuit is a computation model that utilizes a combination of quantum gates to perform quantum operations on qubits. Quantum gates manipulate the quantum state of input qubits, leading to a final state that represents the computation's outcome. These outcomes are probabilistic so requires multiple measurements are required to obtain final results. One property of quantum circuits is reversiblility. This arises from the fact that each quantum gate is unitary, imply that the input state can be recovered from the output qubits using some unitary gates. The nature of quantum gates ensures that the evolution of the quantum state is traceable in both forward and backward directions.</p>

			<p>Understanding quantum circuits are easy for individuals with a background in classical digital circuits.
				Both classical and quantum circuits follow the rule of bit or qubit from input to output through quantum gates.
				The different is that qubits have superposition, leading different quantum states exists at the same.
			</p>
			<p>There are comparasion between classical and quantum circuits.</p>
			<p>1. Basic circuit composition:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: AND, OR, NOT, and XOR gates that perform classical Boolean operations on bits.</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: X, Y, Z, CNOT gates, etc, that acts quantum bits.</p>
			<p>2. Flow of Circuits:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: information flows through classical bits.</p>
			<p><span class="large-bullet">&#9642;</span>Quantum circuits: information flows through qubits.</p>
			<p>3. Mathematical Model:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: Boolean algebra is used to represent bits and handle computation.</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: unitary vectors are represented quantum states and unitary matrix as quantum gates. Linear algebra is used to describe the procedure of quantum circuits.</p>
			<p>4. Superposition:</p>
				<p><span class="large-bullet">&#9642;</span>Classical digital circuits: process one bit at one time</p>
				<p><span class="large-bullet">&#9642;</span>Quantum circuits: allow for the parallel manipulation of multiple quantum states becaues of the principles of superposition and entanglement.</p>
			<p></p>

			<h3>3.3.1 A quantum circuit</h3>
			<p>A simple quantum circuit from the book, "Classical and Quantum Information Theory: An Introduction for the Telecom Scientist"[1],
				is as an example to explain the flow of quantum circuits. Similar to classical circuits,
				the progression unfolds from right to left, with each step involving the execution of quantum gates on qubits.</p>

			<img src="../fig/Circuit.png" id="centerImg">
			<p>
				When |a> = |0>,
				\[ |0>|x> \xrightarrow{CU} |0>|x> \xrightarrow{XA} X|0>A|x> = |1>A|x> \xrightarrow{CU'}
					|1>U'A|x> \]
				When |a> = |1>,
				\[ |1>|x> \xrightarrow{CU} |1>U|x> \xrightarrow{XA} X|1>AU|x> = |0>AU|x> \xrightarrow{CU'}
					|0>AU|x> \]
				When |a> = \(\alpha|0> + \beta|1>\),
					\[ \alpha|0>|x> + \beta|1>|x> \xrightarrow{}  \alpha|1>U'A|x> + \beta|0>AU|x>\]
			</p>

			<div>
				<h3><b>3.3.2 Quantum circuit for bell states</b></h3>
				<p>A Bell state, also called as an entangled state or EPR pair(Einsten-Podolsky-Rosen pair), is a specific
					entangled quantum states of two qubits. John Bell introduced Bell inequalities that was designed to test
					the entangled part of the property of quantum mechanics. The Bell states can be constructed through
					the quantum circuits as follows. When some entanged qubits are prepared, the Bell quantum circuit can be applied into customed quantum circuits.
				</p>
				<img src="../fig/BellCircuit.png" id="centerImg">
				<p>When the input qubit |q0> = |0> and |q1> = |0>, </p>
				<div>
					\[
						|0>|0> \xrightarrow{H_{0}} H|0>|0> = \frac{1}{\sqrt{2}}(|0>+|1>)|0> \xrightarrow{CNOT_{01}}
						\frac{1}{\sqrt{2}}(|00> + |11>)
					\]
				</div>
				<p>The output qubit is \(\frac{1}{\sqrt{2}}(|00> + |11>)\)</p>
				<p>In fact, there are four types of Bell states. Another three types as follows:</p>
				<div>
					\[
						\beta_{01} = \frac{1}{\sqrt{2}}(|01> + |10>) \\
						\beta_{10} = \frac{1}{\sqrt{2}}(|00> - |11>) \\
						\beta_{11} = \frac{1}{\sqrt{2}}(|01> - |10>)
					\]
					<p>It means that the input qubits are |01>, |10> and |11> respectively in the quantum circuit above.</p>
				</div>
			</div>
			<h3>3.3.3 Toffoli Gate</h3>
			<p>Toffoli Gate: includes H gate, T gate, \(T^\dagger\) gate and CNOT gate.</p>
			<img src="../fig/Toffoli_n.png" id="centerImg">
			<p>The quantum circuit equals Toffoli gate.</p>

			<h3><b>3.3.4 Quantum full adder</b></h3>

			<p>The add cirucit use CNOT and CCNOT circuits so it is important to know the output state of the target qubit of CNOT and CCNOT.</p>
			<p>CNOT gate acts on two qubits, A as control qubit and B as target qubit. </p>
			<p>The output state of CNOT = \(|A>|A \oplus B>\)</p>
			<p>	It is easy to verify it through true table.
				When A is |0> as control qubit, the output of B(target qubit) is unchanged.
				When A is |1> as control qubit, the output state of B(target qubit) flips.
				Therefore, the output state of target is XOR between the state of A and B.
			</p>
			<p>CCNOT gate acts on three qubits, A and B as control qubits and C as target qubit.</p>
			<p>The output state of CCNOT = \(|(A \cdot B) \oplus C>\)</p>
			<p>We can see A and B as one qubit(\(A \cdot B\)) to control the target qubit so it is the same as CNOT gate.</p>

			<p>The quantum circuit of full adder as follows:</p>
			<img src="../fig/Adder.png" id="centerImg">
			<p>We derive the math expression of \(C_{out}\) and S seperately. </p>
			<p></p>
			<div>In the stage 1,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |B> \\
					|C_{out}> &= |(AB) \oplus 0> = |AB>
					\end{align}
				\]
			</div>
			<div>
				In the state 2,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |(AB) \oplus 0> = |AB>
					\end{align}
				\]
			</div>
			<div>
				In the stage 3,
				\[
					\begin{align}
					|S> &= |C_{in}> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}
				\]

				In the stage 4,

					\begin{align}
					|S> &= |C_{in} \oplus A \oplus B> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}

				In the final stage,
					\begin{align}
					|S> &= |C_{in} \oplus A \oplus B> \\
					|A'> &= |A> \\
					|B'> &= |A \oplus B> \\
					|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
					\end{align}
				<p>From the equation above, we can see the expression state of |S> equals the math one of S of a full adder.</p>

				<p>However, the expression of \(C_{out}\) is different from the one of a full adder. We can simply the expression to verify that they are the same one.</p>
				<div>
					\[
						\begin{align}
							|C_{out}> &= |AB \oplus [C_{in} \cdot (A \oplus B)]>
						\end{align}
					\]
					We can use X represents \(A \oplus B\), then


					\[
						\begin{align}

							|C_{out}> &= |AB \oplus [C_{in} \cdot X]> \\
									  &= |AB \overline{C_{in}X} + \overline{AB} C_{in}X>\\
									  &= |AB(\overline{C_{in}} + \overline{X}) + (\overline{A}+\overline{B})C_{in}X> \\
									  &= |AB(\overline{C_{in}} + \overline{A\oplus B}) + (\overline{A}+\overline{B})C_{in}\overline{A\oplus B})> \\
									  &= |AB(\overline{C_{in}} + AB + \overline{A}\overline{B}) + (\overline{A}+\overline{B})(A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB\overline{C_{in}} + AB + (A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB + (A\overline{B} + \overline{A}B)C_{in}> \\
									  &= |AB + (A\oplus B) \cdot C_{in}>
						\end{align}

					\]
					<p>We can see the expression of \(|C_{out}>\) equals the \(C_{out}\) of a full adder.
						Therefore, the quantum full adder circuit can have the function of adding two qubits with carry.</p>
				</div>
			</div>

			<p>For example, before we use the quantum full adder, we need to prepare the input qubit for
				the value we want to compute. For example, when A = 0, B = 0, Cin = 1 and A = 1, B = 1, Cin = 1, we need
				to design quantum circuit to satisfy the condition. I used qiskit simulator to make
				the quantum circuit and got the measurement outcome of the circuit. The quantum circuit as follows:</p>
			<img src="../fig/adder_preparation_qiskit1.png" id="centerImg">

			<img src="../fig/adder_preparation_qiskit2.png" id="centerImg">
			<p>The first qubit |q0> is Cin, the second |q2> and third qubits |q3> are A and B, the last qubit |q4> is |0> as the input qubits.
				We prepared input quantum states, one is |A> = |B> = |0>,  |Cin> = |1>, and the other is |A> = |B> = |1>, |Cin> = |1>.
				In Qiskit, note the first qubit is the rightest one in the figure.
				The outcome in the figure is |0001> with the probability with 677/1024, and |0111> with 347/1024.

			</p>
			<img src="../fig/adder_qiskit1.png" id="centerImg">
			<img src="../fig/adder_qiskit2.png" id="centerImg">
			<p>In the figure, from the right to left, the first qubit of the final result is the sum of A and B, the second and third one are A and B,
				and the last one is the carry. </p>
			<p>In the figure, |0001> represents the carry is 0 and the sum of A and B is 1 when A = B = 0, and Cin = 1.
				Its probability is 653/1024 which is close to 677/1024.
				|1111> represents the carray is the carry is 1 and the sum of A and B is 1 when A = B = 1, and Cin = 1.
				Its probability is 371/1024 which is close to 647/1024.
				It means that the quantum circuit can perform the function of a full adder.
			</p>

			<p></p>
			<p>The preceding illustration described a one bit full adder. Now, consider the figure below,
			representing a two bit full adder composed of two such one bit adders, such as A = 01 and B = |11>.
				This conceptual framework
			can be extended to design quantum adders for systems involving multiple bits.</p>

			<img src="../fig/Adder_N.png" id="centerImg">
			<p>When 01 and 11 are as the input of a two bit full adder, it means that |A0> = |1>,
			|A1> = |0>, |B> = |1>, and |B>=|1>. The Cout of first adder is as the input Cin of the second adder.
				The output of |S0>, |S1>, and |Cout> represent the first bit and the second bit of Sum (from right to left),
			and the carry bit value. The sum of 01 and 11 equals 100 so |S0> = |0>, |S1 > = |0> and |Cout> = |1>.</p>

			<p>
				When multiple qubits add respectively, it only prepares the input qubits in superposition.
				When the sum of the 11 and 01, it prepares |A0> = |1>, |A1> = |1>, |B0> = |1>, and |B1> = |0>.
				when the sum of the 00 and 10, it prepares |A0> = |0>, |A1> = |0>, |B0> = |0>, and |B1> = |1>.

				Therefore, |A0>|B0>|A1>|B1> needs to be |1110> and |0001> in the superposition.
				<img src="../fig/two_bit_adder1.png" id="centerImg">
				<img src="../fig/two_bit_adder2.png" id="centerImg">
				<img src="../fig/two_bit_adder3.png" id="centerImg">
			</p>
			<p>From the outcome of qiskit, qubits are in the superposition with |01100100> and |0000010>(from the right to left in the figure).
				It illustrates that |A0>|B0>|A1>|B1> is in |1110> and |0001> with the probability of 326/1024 and 698/1024 respectively.
			</p>

			<img src="../fig/two_bit_adder.png" id="centerImg">
			<img src="../fig/two_bit_adder5.png" id="centerImg">
			<p>The outcome |S0>|A0>|B0>|S1>|A1>|B1>|Cout> in the figure is |0001010> and |0110101>(from the right to left in the figure).</p>
			<p>	|0001010> is |S0> = |0>, |A0> = |0>, |B0> = |0>, |S1> = |1>, |A1> = |0>, |B1> = |1>, |Cout> = |0>, so it means
				the sum of 00 and 10 equals 010.</p>
			<p>	|0110101> is |S0> = |0>, |A0> = |1>, |B0> = |1>, |S1> = |0>, |A1> = |1>, |B1> = |0>, |Cout> = |1>, so it means
				the sum of 11 and 01 equals 100.
			</p>

			<h3><a>3.3.5 Quantum binary multiplication</a></h3>
			The method is from the paper[2] that introduce the detailed process of constructing quantum multiplication.
			In classical multiplication, each digital of one number A is multiplied by each digital of another number B, and then
			add up the results according to their place values.
			<p></p>
			<img src="../fig/Multiplication.png" id="centerImg">

			<p>The method of quantum multiplication is to construct two binary number multiplication and full adder. The binary numbers A and B
				are represented using qubits. Toffoli gate is used to perform multiplication computation between qubits.
				After multiplication, the results are added together using a quantum full adder. For example, firstly, the binary numbers A(\(A_3A_2A_1A_0\)) and B(\(B_3B_2B_1B_0\))
				are encoded by qubits. In the second step, \(B_3A_0\), \(B_2A_0\), \(B_1A_0\), and \(B_0A_0\) are constructed respectively, then
				the results are added together. The second step is continued to perform repeatedly until all the binary number of A and B are computed.
			</p>
			<img src="../fig/multiplication_qubit.png" id="centerImg">
			<p>In the blue part of the figure, Ai and B0 ... Bn-1 are multiplied respectively using Toffoli gates.
				In the red part of the figure, a full adder is used to add the outputs of C0 and C1. In the yellow part,
				the C0 is recovered to the quantum states |000>. This is because it needs to continue to perform Ai and B0 ... Bn-1 multiplication.
			</p>
			<p>For example, I built a quantum circuit to multiple two numbers mod \(2^3\) with the binary length of 3. The first three qubits (q0, q1, q2) encode A,
			qubits (q3, q4, q5) encodes 8, qubits (q6, q7, q8) represents \(A_i * B_j\), qubits (q9, q10, q11) represents A0 * B0, A0 * B1, A0 * B2,
			qubits (12, 13, 14) represents the sum of the first addition(A0*B2 A0*B1 A0*B0 + A1*B1 A1*B0), qubit q15 represents the carry,
			qubits (16, 17, 18) represents the sum of the second addition (qubits(12, 13, 14) + A2*B0), qubit 19 represents the carry.
			The final result is qubits (16, 17, 18), the carry deleted because it needs to mod 8. </p>
			<img src="../fig/multiplication_qiskit_1.png" id="centerImg">
			<img src="../fig/multiplication_qiskit_2.png" id="centerImg">
			<img src="../fig/multiplication_qiskit_3.png" id="centerImg">

			<p>Qiskit example lists A and B range from 0 and 15 and the final results mod 8. It requires the number of qubits </p>
			<div>
				\[2 * L_{a} + 2 * L_{c} + 2 * (L_{c} + 1)\]
			</div>
			<p>\(L_a\) represents the length of the encoding binary string of A or B.
			\(L_c\) represents the length of the encoding binary string of the final result. In the example, \(L_a\) and \(Lc\) are 3 so the length of
				qubits is 20.</p>
			<p></p>

			<h3>Reference</h3>
			<p>1. Desurvire, Emmanuel. (2009). Classical and Quantum Information Theory: An Introduction for the Telecom Scientist. 10.1017/CBO9780511803758. </p>
			<p>2. Cho, S. M., Kim, A., Choi, D., Choi, B. S., & Seo, S. H. (2020).
				Quantum modular multiplication. IEEE Access, 8, 213244-213252.</p>
		</div>
	</section>



    <section id="contact" class="contact">
        <div class="container">
            <h2>Contact Me</h2>
            <p>Email: tankzhang19@gmail.com</p>
            <p>LinkedIn: linkedin.com/in/zhang-hongfeng-176122270/</p>
            <!-- Add more contact information as needed -->
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2023 Hongfeng Zhang</p>
        </div>
    </footer>

</body>
</html>

